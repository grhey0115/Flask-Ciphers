// Key strength calculation with improved metrics
function calculateKeyStrength(key, cipherType) {
    if (!key) return 0;
    let strength = 0;
    
    // Base criteria
    const hasUpperCase = /[A-Z]/.test(key);
    const hasLowerCase = /[a-z]/.test(key);
    const hasNumbers = /[0-9]/.test(key);
    const hasSpecialChars = /[^A-Za-z0-9]/.test(key);
    
    // Length-based score (up to 25 points)
    strength += Math.min(25, Math.floor((key.length / 32) * 25));
    
    // Character variety score (up to 40 points)
    if (hasUpperCase) strength += 10;
    if (hasLowerCase) strength += 10;
    if (hasNumbers) strength += 10;
    if (hasSpecialChars) strength += 10;
    
    // Cipher-specific adjustments
    switch(cipherType) {
        case 'caesar':
            // Caesar cipher is inherently weak
            strength = Math.min(30, strength);
            if (/^\d+$/.test(key) && parseInt(key) >= 0 && parseInt(key) <= 25) {
                strength = Math.max(10, strength);
            }
            break;
            
        case 'vigenere':
            // Vigenere benefits from longer keys
            if (key.length < 5) strength *= 0.5;
            else if (key.length > 10) strength *= 1.2;
            strength = Math.min(85, strength);
            break;
            
        case 'playfair':
            // Playfair needs a good keyword
            if (key.length < 6) strength *= 0.7;
            if (/^[A-Za-z]+$/.test(key)) strength *= 1.1;
            strength = Math.min(90, strength);
            break;
            
        case 'aes':
            // AES-256 needs exactly 32 characters
            if (key.length === 32) {
                strength = Math.min(100, strength * 1.5);
            } else {
                strength *= 0.5;
            }
            break;
            
        case 'double-columnar':
            // Double columnar benefits from complexity
            strength *= 1.2;
            break;
    }
    
    return Math.round(Math.min(100, strength));
}

// Character count with detailed statistics
function updateCharacterStats(text) {
    if (!text) {
        return {
            total: 0,
            letters: 0,
            numbers: 0,
            spaces: 0,
            special: 0
        };
    }
    
    const stats = {
        total: text.length,
        letters: text.replace(/[^A-Za-z]/g, '').length,
        numbers: text.replace(/[^0-9]/g, '').length,
        spaces: text.replace(/[^ ]/g, '').length,
        special: text.replace(/[A-Za-z0-9 ]/g, '').length
    };
    
    return stats;
}

// Solution steps generator
function generateSolutionSteps(method, input, key) {
    const steps = {
        1: '', // Input Processing
        2: '', // Key Generation/Processing
        3: '', // Encryption/Decryption Process
        4: ''  // Final Output
    };
    
    switch(method) {
        case 'caesar':
            steps[1] = `Input text "${input}" is normalized by converting to uppercase and removing special characters.`;
            steps[2] = `Shift value of ${key} is validated to be between 0-25.`;
            steps[3] = `Each character is shifted ${key} positions in the alphabet using the formula: (char_position + shift) % 26`;
            steps[4] = `The final output is generated by applying the shift to each character.`;
            break;
            
        case 'vigenere':
            steps[1] = `Input text "${input}" is prepared by removing non-alphabetic characters.`;
            steps[2] = `Key "${key}" is repeated to match input length: ${key.repeat(Math.ceil(input.length/key.length)).slice(0, input.length)}`;
            steps[3] = `Each character is shifted based on the corresponding key character position.`;
            steps[4] = `The VigenÃ¨re table is used to combine the input with the repeated key.`;
            break;
            
        case 'playfair':
            steps[1] = `Input text "${input}" is split into digraphs (pairs of letters).`;
            steps[2] = `Key "${key}" is used to generate the 5x5 Playfair matrix.`;
            steps[3] = `Each digraph is processed according to Playfair rules (same row, column, or rectangle).`;
            steps[4] = `The final output is generated by combining the transformed digraphs.`;
            break;
            
        // Add cases for other cipher types...
    }
    
    return steps;
}

// Event listeners and UI updates
document.addEventListener('DOMContentLoaded', function() {
    const inputText = document.getElementById('inputText');
    const key = document.getElementById('key');
    const cipherType = document.getElementById('cipherType');
    
    function updateUI() {
        // Update key strength
        const strength = calculateKeyStrength(key.value, cipherType.value);
        document.getElementById('keyStrength').textContent = `${strength}%`;
        
        // Update character statistics
        const stats = updateCharacterStats(inputText.value);
        document.getElementById('charCount').textContent = `${stats.total} (${stats.letters} letters, ${stats.numbers} numbers, ${stats.spaces} spaces, ${stats.special} special)`;
    }
    
    // Add event listeners
    inputText.addEventListener('input', updateUI);
    key.addEventListener('input', updateUI);
    cipherType.addEventListener('change', updateUI);
    
    // Initial UI update
    updateUI();
});

// Export functions for external use
export {
    calculateKeyStrength,
    updateCharacterStats,
    generateSolutionSteps
};